# Implementing-EDF-Scheduler
 implementation of EDF scheduler based on FreeRTOS and testing OS Performance. 
 
 <html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h2>Implementing EDF Scheduler</h2></strong><em><span style="text-decoration:underline;">Disclaimer : This project is part of &quot;Advanced Embedded Systems&quot; Nanodegree attended at Udacity and FWD program.</span></em><br /><br /><h2>Project Mission:</h2>⇒ Earliest Deadline First (EDF) is a shecduling algorithm that adopts a dynamic priority-based preemptive scheduling policy, meaning that the priority of a task can change during its execution, and the processing of any task is interrupted by a request for any higher priority task.<br />⇒ The project aims to design an EDF scheduler based on FreeRTOS.<br /><br /><br /><h2>Project Components:</h2><h3>1) Modifying FreeRTOS Code to add EDF Scheduler: </h3><br /><em><span style="text-decoration:underline;">Disclaimer : The first section in this part of the project is based on the research “</span></em><a href="https://docs.google.com/viewer?url=http%3A%2F%2Fberu.univ-brest.fr%2Fcheddar%2Fcontribs%2Fexamples_of_use%2Fcarraro16.pdf">Implementation and Test of EDF and LLREFSchedulers in FreeRTOS</a><em><span style="text-decoration:underline;">”  published from &quot;</span></em><em><strong><span style="text-decoration:underline;">Universita degli Studi di Padova&quot;</span></strong></em><em><span style="text-decoration:underline;"> University</span></em><br /><br /><h3>2) Testing the Real-Time Operating System working with EDF Scheduler after modifications:</h3><br />⇒ Created 4 tasks to test the OS with the following criteria:<br />	• Task 1: &quot;&quot;Button_1_Monitor&quot;&quot;, {Periodicity: 50, Deadline: 50}<br />	This task will monitor rising and falling edge on button 1 and send this event to the consumer task. (Note: The rising and failling edges are treated as separate events, hence they have separate strings)<br />	• Task 2: &quot;&quot;Button_2_Monitor&quot;&quot;, {Periodicity: 50, Deadline: 50}<br />	This task will monitor rising and falling edge on button 2 and send this event to the consumer task. (Note: The rising and failling edges are treated as separate events, hence they have separate strings)<br />	• Task 3: &quot;&quot;Periodic_Transmitter&quot;&quot;, {Periodicity: 100, Deadline: 100}<br />	This task will send preiodic string every 100ms to the consumer task<br />	• Task 4: &quot;&quot;Uart_Receiver&quot;&quot;, {Periodicity: 20, Deadline: 20}<br />	This is the consumer task which will write on UART any received string from other tasks<br />	•  5th and 6th task to simulate a heavier load:<br />	Task 5: &quot;&quot;Load_1_Simulation&quot;&quot;, {Periodicity: 10, Deadline: 10}, Execution time: 5ms<br />	Task 6: &quot;&quot;Load_2_Simulation&quot;&quot;, {Periodicity: 100, Deadline: 100}, Execution time: 12ms<br />	These two tasks  implemented as en empty loop that loops X times to achieve the required execution time mentioned above. (Note: In run-time, used GPIOs and logic analyzer to determine the execution time)<br /><strong>NOTE : Project was implemented on NXP ARM7_LPC2129 Microcontroller and Keil IDE </strong><br /><br />⇒ Verified system implementation Offline using the following calculations:<br />    • For all the tasks, calculated the execution time from the actual implemented tasks using GPIOs and the logic analyzer<br />	• Calculated the system hyperperiod<br />	• Calculated the CPU load<br />	• Checked the system schedulability using URM and time demand analysis techniques (Assuming the given set of tasks are scheduled using a fixed priority rate -monotonic scheduler)<br />    • Using Simso offline simulator, simulated the given set of tasks<br /><br />⇒ Verified system implementation in Run-Time using Keil Simulator :<br />	• Calculated the CPU usage time using timer 1 and trace macros<br />	• Using trace macros and GPIOs, ploted the execution of all tasks, tick, and the idle task on the logic analyzer<br /><br /><br /></div>
</body>
</html>
